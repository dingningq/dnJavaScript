<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>获取某一个容器中的元素子节点</title>
</head>
<body>
<div id="box">
    <div></div>
    <div></div>
    <div>
        <p></p>

        <p>

        </p>
    </div>
    <p></p>

    <p></p>

    <p>

    </p>

</div>
<script src="js/utils.js"></script>
<script>
    var oDiv = document.getElementById("box");

    /*//->首先获取所有的子节点(childNodes),在所有的子节点中，把元素节点过滤出来(nodeType===1)
    //->如果多传递一个标签名的话，我们还要获取的子元素集合中把对应标签名的进行二次筛选
    function children(curEle, tagName) {
        var ary = [];
        //->IE6-8下不能使用内置的children属性，我们自己写代码实现
        if (/MSIE (6|7|8)/i.test(navigator.userAgent)) {
            var nodeList = curEle.childNodes;
            for (var i = 0, len = nodeList.length; i < len; i++) {
                var curNode = nodeList[i];
                if (curNode.nodeType === 1) {
                    ary[ary.length] = curNode;
                }
            }
        } else {
            //->标准浏览器中，我们直接使用children即可，但是这样获取的是一个元素集合（类数组），为了和IE6-8保持一致，我们借用数组原型上slice，实现把类数组转换为数组
            ary = Array.prototype.slice.call(curEle.children);
        }

        //[div,div,p,p,p] len=6 k=0 k<6 k++ 随着数组长度一直在删减，数组会踏现
        console.log(ary);
        //->二次筛选
        if (typeof tagName === "string") {

            for (k = 0;  k <ary.length; k++) {
                var curTag = ary[k];

                if (curTag.nodeName.toLowerCase() !== tagName.toLowerCase()) {

                    //->不是我想要的标签
                    ary.splice(k, 1);
                    k--;
                    console.log(ary);
                }

            }
        }

        return ary;
    }*/
    console.log(utils.children(oDiv, "p").length);
</script>
</body>
</html>