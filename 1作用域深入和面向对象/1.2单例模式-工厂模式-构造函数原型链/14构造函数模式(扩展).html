<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
<script>
    //    function Fn(){
    //        //this->f1
    //        this.x=100;
    //        this.getX=function(){
    //            //this->需要看getX执行的时候才知道
    //            console.log(this.x);
    //        }
    //    }
    //    var f1=new Fn;
    //    f1.getX();//方法中的this是f1->100
    //    var ss=f1.getX;
    //    ss();//方法中的this是window->undefined 一个对象当中,如果没有这个属性名,获取他是undefined;

    //1.在构造函数模式中 new Fn()执行,如果Fn不需要传递参数的话,后面的小括号可以省略
    //2.this的问题,在类中出现的this.xxx=xxx中的this都是当前类的实例,而某一个属性值(方法),方法中的this需要看方法执行的时候,前面是否有"."才能知道this是谁

    //    function Fn(){
    //        var num=10;
    //        this.x=100;
    //        this.getX=function(){
    //            console.log(this.num);
    //        }
    //    }
    //    var f1=new Fn;
    //    console.log(f1.num); //->对象里如果没有这个属性名就是undefined;
    //    var ss=f1.getX;
    //    ss();//->window.num->对象里如果没有这个属性名就是undefined;

    //3.类有普通函数的一面,当函数执行的时候,var num其实只是当前形成的私有作用域中的私有变量而以,它和我们的 f1这个实例没有任何的关系,只有this.xxx=xxx才相当于给f1这个实例增加私有的属性和方法,才和我们的f1有关系...

    //    function Fn() {
    //        this.x = 100;
    //        this.y = 200;
    //        this.getX = function () {
    //            console.log(this.x);
    //        };
    //        //return 100;
    //        return {name:"丁宁"}
    //    }
    //    var f2 = new Fn;
    //    console.log(f2);
    //4.在构造函数模式中,浏览器会默认的把我们的实例返回(返回的是一个对象数据类型的值);如果我们自己手动写了return返回:
    //返回的是一个基本数据类型的值,当前实例是不变的,例如:return 100;我们的f1还是当前Fn类的实例
    //返回的是一个引用数据类型的值,当前的实例会被自己返回的值给替换掉,例如: return {name:"丁宁"}我们的f1就不在是Fn的实例了,而是对象 return {name:"丁宁"}

    //    function Fn(){
    //        this.x=100;
    //        this.getX=function(){
    //            console.log(this.x);
    //        }
    //    }
    //    var f1=new Fn;
    //5.检测某一个实例是否属于这个类 ->instanceof
    //    console.log(f1 instanceof Fn); //->true
    //    console.log(f1 instanceof Array);//->false
    //    console.log(f1 instanceof Object); //->true 因为所有的实例都是对象数据类型的,而每一个对象数据类型都是Object这个内置类的一个实例,所以f1也是它的一个实例
    //对于检测数据类型来说,typeof有自己的局限性,不能细分Object下的对象,数组,正则..
    //var a=[];
    //console.log(a instanceof Array);//true说明a是一个数组

    //        function Fn() {
    //            this.x = 100;
    //            this.getX = function () {
    //                console.log(this.x);
    //            }
    //        }
    //        Fn.prototype.getY = function () {
    //            console.log(this.y);
    //        };
    //        var f1 = new Fn;
    //        var f2 = new Fn;
    //6.f1和f2都是Fn这个类的一个实例，都拥有x和getX两个属性，但是这两个属性是各自的私有的属性，所以：
    //    console.log(f1.getX===f2.getX); //->false
    //    console.log(f1.getY===f2.getY);//->true
    //in检测某一个属性是否属于这个对象 attr in Object， 不管是私有的属性还是公有的属性，只要存在，用in来检测都是true
    // console.log("getX"in f1); //->true 是它的一个属性

    //hasOwnProperty:用来检测某一个属性是否为这个对象的“私有属性”，这个方法只能检测私有的属性
    //console.log(f1.hasOwnProperty("getX"));//->true "getX"是f1的私有属性

    //思考：检测某一个属性是否为该对象的“公有属性” hasPubProperty
    //function hasPubProperty(obj,attr){
    //   return attr in obj && !obj.hasOwnProperty(attr);
    //}

    //console.log(hasPubProperty(f1,"getY")); //->true
    //console.log(hasPubProperty(f1,"getX")); //->false

    //7.isPrototypeOf 自己回去查看高程3或者百度自己找到答案  //obj1是否被包含在obj2的原型链中

    //    var ary=[];
    //    var ary2=[];
    //    console.log(Array.prototype. isPrototypeOf(ary));  //Array是否被包含ary在的原型链中
    //    console.log(ary2.isPrototypeOf(ary));
</script>
</body>
</html>