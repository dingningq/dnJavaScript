<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>柯理化函数</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        body {
            background: #006600;
            cursor: pointer;
        }
    </style>

</head>
<body>
<script>
    //->柯理化函数思想：一个JS预先处理的思想->利用函数执行可以形成一个不销毁的私有作用域原理，把需要预先处理的内容都存在这个不销毁的作用域中，并且返回一个小函数，以后我们执行的都是小函数，在小函数中把之前预先存储的值 进行
    //bind:把传递进来的callBack这个方法中的this预先处理给context
    //    function bind(callBack, context) {
    //        var outerArg = Array.prototype.slice.call(arguments, 2);
    //
    //
    //        return function () {
    //            var innerArg=Array.prototype.slice.call(arguments,0);
    //
    //            callBack.apply(context, outerArg.concat(innerArg));
    //        }
    //    }
    //
    //
    //    var obj = {name: "丁宁"};
    //    function fn(num1, num2) {
    //        console.log(this, num1, num2,arguments[2]);
    //    }
    //    document.body.onclick=fn.bind(obj,100,200);//->除了预先处理的this和需要手动传递的参数值以外，把浏览器默认给传递的鼠标事件对象也进行预先处理了


    //document.body.onclick=fn
    //->fn中的this:body,num1:MouseEvent num2：undefined


    //    document.body.onclick=function(e){
    //    //->给元素的某一个行为绑定方法，当行为触发的时候，执行的对应的方法，此时方法中的this是当前元素本身，而且浏览器还会给当前的方法默认的传递一个参数值：MouseEvent(鼠标事件对象) 在IE6-8下并没有传递这个值 window.event中存储的
    //        console.log(e);
    //    }


    //window.setTimeout(bind(fn,obj,100,200),1000); //给定时器绑定一个方法，当定时器到达时间的时候让fn执行，并且让fn中this变为obj

</script>
</body>
</html>